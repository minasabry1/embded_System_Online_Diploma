/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

typedef volatile unsigned int vuint32_t ;
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
// register address


//GPIOA
#define GPIOA_BASE 0x40010800
#define GPIOA_CRH *(volatile uint32_t *)(GPIOA_BASE + 0x04)
#define GPIOA_CRL *(volatile uint32_t *)(GPIOA_BASE + 0x00)
#define GPIOA_ODR *(volatile uint32_t *)(GPIOA_BASE + 0x0C)
#define GPIOA_IDR *(volatile uint32_t *)(GPIOA_BASE + 0x08)
#define GPIOA13 (1UL<<13)

#define GPIOB_BASE 0x40010C00
#define GPIOB_CRH *(volatile uint32_t *)(GPIOB_BASE + 0x04)
#define GPIOB_CRL *(volatile uint32_t *)(GPIOB_BASE + 0x00)
#define GPIOB_ODR *(volatile uint32_t *)(GPIOB_BASE + 0x0C)
#define GPIOB_IDR *(volatile uint32_t *)(GPIOB_BASE + 0x08)
//RCC
#define RCC_BASE 0x40021000
#define RCC_APB2ENR *(volatile uint32_t *)(RCC_BASE + 0x18)
#define RCC_CFGR *(volatile uint32_t *)(RCC_BASE + 0x04)
#define RCC_CR *(volatile uint32_t *)(RCC_BASE + 0x00)
#define RCC_IOPAEN 1<<2 //offeset name of RCC_APB2ENR register
#define RCC_IOPBEN 1<<3 //offeset name of RCC_APB2ENR register
/*Bit 2 IOPAEN: IO port A clock enable
Set and cleared by software.
0: IO port A clock disabled
1: IO port A clock enabled

it is important for GPIOA. The GPIOA peripheral is connected to the APB2 bus,
and therefore its clock must be enabled in order to use it.The RCC_APB2ENR register is used to control the clock for GPIOA.
 If the clock for GPIOA is not enabled, you will not be able to read or write data to the GPIOA port,
 and the port will not function as expected.To use GPIOA,
 you need to set the appropriate bit in the RCC_APB2ENR register to 1, which will enable the clock for the GPIOA peripheral.
 lazm ya3ne a5le l RCC_IOPAEN enable 3l4an a5le kol l matwsl b APB2 periphales enabled
 */
void clock_Init(){
	//Enable clock IOPA EN
	RCC_APB2ENR |=RCC_IOPAEN;
	//Enable clock IOPB EN
	RCC_APB2ENR |=RCC_IOPBEN;

}
void GPIOA_INIT(){
	GPIOA_CRL=0x0;
	GPIOA_CRH=0x0;
	GPIOB_CRL=0x0;
	GPIOB_CRH=0x0;
	//Pin A1 is INPUT HighZ
	//00: Input mode (reset state)
	GPIOA_CRL &=~(1<<4);
	GPIOA_CRL &=~(1<<5);
	//01: Floating input (reset state)
	GPIOA_CRL |=(1<<6);
	GPIOA_CRL &=~(1<<7);

	//Pin A13 is INPUT HighZ
	//00: Input mode (reset state)
	GPIOA_CRH &=~(1<<20);
	GPIOA_CRH &=~(1<<21);
	//01: Floating input (reset state)
	GPIOA_CRH |=(1<<22);
	GPIOA_CRH &=~(1<<23);

	//Pin B1 is OUTPUT
	//01: Output mode, max speed 10 MHz.
	GPIOB_CRL |=(0b01 <<4);
	//00: General purpose output push-pull
	GPIOB_CRL &=~(0b11 <<6);

	//Pin B13 is OUTPUT
	//01: Output mode, max speed 10 MHz.
	GPIOB_CRH |=(0b01 <<20);
	//00: General purpose output push-pull
	GPIOB_CRH &=~(0b11 <<22);

}
my_wait(int a){
	unsigned int i,j;
	for(i=0;i<a;i++)
		for(j=0;j<255;j++);


}

int main(void)
{
	clock_Init();
	GPIOA_INIT();

	while(1){
		//Read Bit 1  ..PA1>>Connected External to PUR
		if(((GPIOA_IDR &(1<<1))>>1) ==0)//Press
		{
			GPIOB_ODR ^=(1<<1);//toggle bit 1 >>B1
			while((((GPIOA_IDR &(1<<1))>>1) ==0));//Single press ..while am pressing>> same action
		}
		//Read Bit 13  ..PA13>>Connected External to PDR
				if(((GPIOA_IDR &(1<<13))>>13) ==1)//Multi Pressing
				{
					GPIOB_ODR ^=(1<<13);//toggle bit 13 >>B13
					my_wait(1);

				}

	}

}
